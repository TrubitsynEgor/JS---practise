'use strict'

//? Вычислить сумму чисел до данного
//Напишите функцию sumTo(n), которая вычисляет сумму чисел 1 + 2 + ... + n.

//? C помощбю цикла for
// Тут без коментариев...
function sumTo(n) {
	let sum = 0;
	for (let i = 1; i <= n; i++) {
		sum += i;
	}
	return sum
}
console.log(sumTo(4));


// C помощью РЕКУРСИИ!

function sumToRecursion(n) {
	if (n == 1) return 1;
	return n += sumToRecursion(--n);
}
console.log(sumToRecursion(4));
//? в стеке запоминаются контексты выполнения (sumToRecursion(4) => (sumToRecursion(3) =>(sumToRecursion(2) =>(sumToRecursion(1) =>
// На этапе =>(sumToRecursion(1) условия if (n == 1) true. Значит return 1, значение function sumToRecursion(1) == 1!
// Далее если мы знаем что sumToRecursion(1) == 1 то можем посчитать значения sumToRecursion(2) т.е 2+1=3
// (sumToRecursion(3) 3 + 3 = 6; Ну и sumToRecursion(4) 6 + 4 = 10; Значит вызов function sumToRecursion(4) return 10!
//todo Пару десятков раз прогнать на практике и можно разобрасть с рекурсией =D


// Формула сумма арифмитической прогрессии:
function sumToMath(n) {
	return (n + 1) * n / 2;
}// Если нужно ариф прогрессию в промежутке от n до m; к примеру sumToMath(3,8) от 3 до 8 просто передаем в параметры
// sumToMath(m,n) и меняем формулу на: (Math.abs(a-b)+1) *(a+b)/2;  --Math.abs нужен чтобы небыло рвзници между мин и макс в аргументах
console.log(sumToMath(4));

//Todo_| P.S. Надо ли говорить, что решение по формуле работает быстрее всех? Это очевидно.
//Todo_| Оно использует всего три операции для любого n, а цикл и рекурсия требуют как минимум n операций сложения.

//todo| Вариант с циклом – второй по скорости. Он быстрее рекурсии, так как операций сложения столько же, но нет дополнительных
//todo| вычислительных затрат на организацию вложенных вызовов. Поэтому рекурсия в данном случае работает медленнее всех.

/*P.P.S. Некоторые движки поддерживают оптимизацию «хвостового вызова»: если рекурсивный вызов является самым последним 
в функции (sumTo выше не будет оптимизирован, т.к. последним происходит сложение, а не рекурсивный вызов),
то внешней функции не нужно будет возобновлять выполнение и не нужно запоминать контекст его выполнения.
В итоге требования к памяти снижаются, и сумма sumTo(100000) будет успешно вычислена. Но если JavaScript-движок не поддерживает
это (большинство не поддерживают), будет ошибка: максимальный размер стека превышен, так как обычно существует ограничение
на максимальный размер стека. */




