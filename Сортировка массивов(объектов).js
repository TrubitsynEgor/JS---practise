'use strict'

//? Трансформировать в объекты
//* У вас есть массив объектов user, и у каждого из объектов есть name, surname и id.
//*Напишите код, который создаст ещё один массив объектов с параметрами id и fullName, где fullName – состоит из name и surname.

const vasya = { name: "Вася", surname: "Пупкин", id: 1 };
const petya = { name: "Петя", surname: "Иванов", id: 2 };
const masha = { name: "Маша", surname: "Петрова", id: 3 };
const users = [vasya, petya, masha];


let usersMapped = users.map(el => ({ // что для стрелочных функций мы должны использовать дополнительные скобки.
	fullName: `${el.name} ${el.surname}`,
	id: el.id,
}));
// Здесь JavaScript будет трактовать { как начало тела функции, а не начало объекта.
//Чтобы обойти это, нужно заключить их в «нормальные» скобки:
console.log(usersMapped); /* (3) [{…}, {…}, {…}]
0: {fullName: 'Вася Пупкин', id: 1}
1: {fullName: 'Петя Иванов', id: 2}
2: {fullName: 'Маша Петрова', id: 3}
length: 3[[Prototype]]: Array(0) */

//? Отсортировать пользователей по возрасту
//* Напишите функцию sortByAge(users), которая принимает массив объектов со свойством age и сортирует их по нему.

let vasya = { name: "Вася", age: 25 };
let petya = { name: "Петя", age: 30 };
let masha = { name: "Маша", age: 28 };

let arr = [vasya, petya, masha];

function sortByAge(arr) {
	// arr.sort((a, b) => a.age > b.age ? 1 : -1) //<---- "Это более короткая запись"
	arr.sort((a, b) => {
		if (a.age > b.age) {
			return 1;
		} //Стандартная запись основной Compare Function:
		if (a.age < b.age) {
			return -1;
		}
		return 0;
	})
}
sortByAge(arr);
console.log(arr);



//? Перемешайте массив
//* Напишите функцию shuffle(array), которая перемешивает (переупорядочивает случайным образом) элементы массива.
//* Многократные прогоны через shuffle могут привести к разным последовательностям элементов.

let arr = [1, 2, 3];

function shuffle(arr) {
	return arr.sort(() => Math.random() - 0.5)
}
console.log(shuffle(arr));


//? более сложный метод но не вызывает ошибок! https://vc.ru/dev/79158-sluchaynaya-sortirovka-massiva-na-javascript
let myArray = [4, 1, 6, 8, 5, 2, 1];

function rng(arr) {
	return arr
		.map((el, index) => [el, Math.random()])
		.sort((a, b) => a[1] - b[1])
		.map((el) => el[0])
}

console.log(rng(myArray));


/* Есть и другие хорошие способы решить эту задачу. Например, есть отличный алгоритм под названием //! Тасование Фишера — Йетса.
уть заключается в том, чтобы проходить по массиву в обратном порядке и менять местами каждый элемент со случайным элементом,
который находится перед ним. */

function shuffle(array) {
	for (let i = array.length - 1; i > 0; i--) {
		let j = Math.floor(Math.random() * (i + 1)); // случайный индекс от 0 до i

		// поменять элементы местами
		// мы используем для этого синтаксис "деструктурирующее присваивание"
		// подробнее о нём - в следующих главах
		// то же самое можно записать как:
		// let t = array[i]; array[i] = array[j]; array[j] = t
		[array[i], array[j]] = [array[j], array[i]];
	}
}



//? Проверить наш рандом мы можем: 
// подсчёт вероятности для всех возможных вариантов
let count = {
	'123': 0,
	'132': 0,
	'213': 0,
	'231': 0,
	'321': 0,
	'312': 0
};
for (let i = 0; i < 1000000; i++) {
	let array = [1, 2, 3];
	shuffle(array);
	count[array.join('')]++;
}
// показать количество всех возможных вариантов
for (let key in count) {
	alert(`${key}: ${count[key]}`);
}
/* Первый наш код:
123: 250706
132: 124425
213: 249618
231: 124880
312: 125148
321: 125223
Теперь мы отчётливо видим допущенное отклонение: 123 и 213 появляются намного чаще, чем остальные варианты. */

/* Пример с Тасование Фишера - Йетса:
123: 166693
132: 166647
213: 166628
231: 167517
312: 166199
321: 166316
Теперь всё в порядке: все варианты появляются с одинаковой вероятностью. */