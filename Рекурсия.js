'use strict'




function pow(x, n) {
	if (n == 1) return x;
	return x *= pow(x, --n);
}
console.log(pow(2, 3)); // 8


// 1 Создается контекст func pow(2,3)
// 2 Доходя до 3-й строчки контекст pow(2,3) приостонавливается, и запоминается(в спец память) весь контекст связанный с ней.
// 3 Выполлняется вложенный вызов, для каждого из которых создается контекст.
// 4 После их завершения старый контекст достаётся из стека,
// и выполнение внешней функции возобновляется с того места, где она была остановлена.

//? То есть!
// * ШАГ pow(2,3): Контекст выполнения хранит в себе инфу о переменных x=2 and n=3 (1 строка функции) (забили ее в память!)
/* Далее условие n==1 false. Значит переходим к строке return x *= pow(x, --n);
Чтобы вычеслить pow(x, --n) Нужно произвести еще один запуск функции pow но уже с аргументами pow(2,2) */

//* ШАГ pow(2,2): Для выполнения мы(интерпритатор JS) так же запомнили текущий контекст в стеке контекстов выполнения
//* Тут мы вызываем ту же func pow. однако это не важно, для любых func процесс одинаков:
/*
1. Текущий контекст «запоминается» на вершине стека.
2. Создаётся новый контекст для вложенного вызова.
3. Когда выполнение вложенного вызова заканчивается – контекст предыдущего вызова восстанавливается,
и выполнение соответствующей функции продолжается.
*/
//? То есть на момент этого шага у нас в контексте выполнения уже два! контекста pow(2,2) на вершине и следом pow(2,3)
/* И тут происходит тоже самое чтобы вычислить  pow(x, --n) нам вновь нужно вызвать func pow но с аргументами pow(2,1)*/

//* ШАГ pow(2,1): В 3-й строке произваодиться вызов pow(2,1) и Создаётся новый контекст выполнения, предыдущий контекст добавляется в стек:
// Теперь в стеке уже ТРИ контекста (pow(2,1) на вершине, далее pow(2,2) и pow(2,3)) Очередь
//? Ну и на этом шаге далее происходит выход! Т.к условие 	if (n == 1) return x; true мы получаем результат работы
//? function pow(2,1): "x" ну или "2" В нашем случае! И так как вложенных вызовов большк нету функция завершает свою работу
//? вернув "2" а её контекст в памяти-стеке больше не нужен и он удаляется и !!! Восстонавливается предыдущий !!!

//* Возобнавляется вызов pow(2,2) и имея результат выполнеия pow(2,1), pow(2,2) может закончить свою работу:
//* т.е " x *= pow(x, --n); " будет равен "2 *= 2" что будет равнятся "4"; return 4. Func выполнена контекст удаляется из стека

//* Возобнавляется вызов pow(2,3) и зная результ работы pow(2,2) мы можем завершить выполнение pow(3,2):
//* т.е  " x *= pow(x, --n); " будет равен "2" *= "4" === 8. function(pow3,2) return 8. Func выполнена контекст удаляется из стека

//! Таким образом работает рекурсия! в этом примере...




