'use strict'




function pow(x, n) {
	if (n == 1) return x;
	return x *= pow(x, --n);
}
console.log(pow(2, 3)); // 8


// 1 Создается контекст func pow(2,3)
// 2 Доходя до 3-й строчки контекст pow(2,3) приостонавливается, и запоминается(в спец память) весь контекст связанный с ней.
// 3 Выполлняется вложенный вызов, для каждого из которых создается контекст.
// 4 После их завершения старый контекст достаётся из стека,
// и выполнение внешней функции возобновляется с того места, где она была остановлена.

//? То есть!
// * ШАГ pow(2,3): Контекст выполнения хранит в себе инфу о переменных x=2 and n=3 (1 строка функции) (забили ее в память!)
/* Далее условие n==1 false. Значит переходим к строке return x *= pow(x, --n);
Чтобы вычеслить pow(x, --n) Нужно произвести еще один запуск функции pow но уже с аргументами pow(2,2) */

//* ШАГ pow(2,2): Для выполнения мы(интерпритатор JS) так же запомнили текущий контекст в стеке контекстов выполнения
//* Тут мы вызываем ту же func pow. однако это не важно, для любых func процесс одинаков:
/*
1. Текущий контекст «запоминается» на вершине стека.
2. Создаётся новый контекст для вложенного вызова.
3. Когда выполнение вложенного вызова заканчивается – контекст предыдущего вызова восстанавливается,
и выполнение соответствующей функции продолжается.
*/
//? То есть на момент этого шага у нас в контексте выполнения уже два! контекста pow(2,2) на вершине и следом pow(2,3)
/* И тут происходит тоже самое чтобы вычислить  pow(x, --n) нам вновь нужно вызвать func pow но с аргументами pow(2,1)*/

//* ШАГ pow(2,1): В 3-й строке произваодиться вызов pow(2,1) и Создаётся новый контекст выполнения, предыдущий контекст добавляется в стек:
// Теперь в стеке уже ТРИ контекста (pow(2,1) на вершине, далее pow(2,2) и pow(2,3)) Очередь
//? Ну и на этом шаге далее происходит выход! Т.к условие 	if (n == 1) return x; true мы получаем результат работы
//? function pow(2,1): "x" ну или "2" В нашем случае! И так как вложенных вызовов большк нету функция завершает свою работу
//? вернув "2" а её контекст в памяти-стеке больше не нужен и он удаляется и !!! Восстонавливается предыдущий !!!

//* Возобнавляется вызов pow(2,2) и имея результат выполнеия pow(2,1), pow(2,2) может закончить свою работу:
//* т.е " x *= pow(x, --n); " будет равен "2 *= 2" что будет равнятся "4"; return 4. Func выполнена контекст удаляется из стека

//* Возобнавляется вызов pow(2,3) и зная результ работы pow(2,2) мы можем завершить выполнение pow(3,2):
//* т.е  " x *= pow(x, --n); " будет равен "2" *= "4" === 8. function(pow3,2) return 8. Func выполнена контекст удаляется из стека

//! Таким образом работает рекурсия! в этом примере...




//todo | Примеры работы рекурсии для сложных структур данных |

const company2 = [ //? "Это на случай простого перебора с помощью reduce без вложенности!"
	{ name: 'John', salary: 1000, },
	{ name: 'Alice', salary: 600, },
	{ name: 'Mary', salary: 1500, },
	{ name: 'Sveta', salary: 1600, },
	{ name: 'Egor', salary: 800, },
];

const company = { //? Тут более сложный объкт с вложенностями!
	sales: [{ name: 'John', salary: 1000 }, { name: 'Alice', salary: 600 }],
	development: {
		sites: [{ name: 'Peter', age: 25, salary: 2000 }, { name: 'Alex', salary: 1800 }],
		internals: [{ name: 'Jack', salary: 1300 }]
	}
};
//functon просто складывает value ключа salary:
function sumSlaries(departament) {
	if (Array.isArray(departament)) { //если является массивом перебераем методом reduce:
		return departament.reduce((prevValue, curentValue) => prevValue + curentValue.salary, 0);
	} else {
		let sum = 0;

		for (let subDep of Object.values(departament)) { // метод Object.values return array
			sum += sumSlaries(subDep);
			console.log(sum);
		}
		return sum
	}
}
console.log(sumSlaries(company2));




